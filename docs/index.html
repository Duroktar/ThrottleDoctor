<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throttle Doctor: The Workbench</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');

        body {
            font-family: 'Orbitron', sans-serif; /* Futuristic heading font */
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: #0a0a1a; /* Very dark, almost black background */
            color: #00ffff; /* Default neon cyan text */
            overflow-x: hidden; /* Prevent horizontal scroll on subtle effects */
            position: relative; /* For background effects */
        }

        /* Subtle background grid/scanlines effect */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(to right, #00ffff11 1px, transparent 1px),
                linear-gradient(to bottom, #00ffff11 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.1;
            z-index: -1;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 2.5em;
            color: #ff00ff; /* Neon magenta heading */
            text-shadow: 0 0 8px #ff00ff, 0 0 15px #ff00ff; /* Neon glow */
            margin-bottom: 30px;
            letter-spacing: 2px;
            padding-top: 20px;
        }

        .controls, .support-blurb, #output-log {
            background-color: #1a1a2e; /* Darker panel background */
            border: 1px solid #00ffff; /* Neon cyan border */
            box-shadow: 0 0 10px #00ffff44, inset 0 0 5px #00ffff22; /* Subtle inner/outer glow */
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            width: 85%; /* Wider panels */
            max-width: 900px; /* Max width for larger screens */
            box-sizing: border-box;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden; /* For internal glow effects */
        }

        .controls::before, .support-blurb::before, #output-log::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
            box-shadow: 0 0 20px #ff00ff44, inset 0 0 10px #ff00ff22; /* Magenta inner glow */
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
        }


        .controls label {
            font-family: 'Share Tech Mono', monospace; /* Monospace for labels */
            font-size: 1em;
            color: #00e5ff; /* Lighter neon cyan */
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .controls input[type="radio"],
        .controls input[type="checkbox"] {
            accent-color: #ff00ff; /* Neon magenta for checked state */
            transform: scale(1.2); /* Slightly larger checkboxes/radios */
        }

        .controls input[type="number"] {
            width: 80px;
            padding: 8px 12px;
            border: 1px solid #00ffff;
            background-color: #0d0d1a; /* Even darker input background */
            color: #66ff66; /* Neon green for input values */
            border-radius: 6px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 1em;
            box-shadow: inset 0 0 5px #00ffff33;
        }

        button {
            font-family: 'Orbitron', sans-serif;
            padding: 14px 30px;
            font-size: 1.1em;
            background: linear-gradient(45deg, #00ffff, #ff00ff); /* Gradient button */
            color: #0a0a1a; /* Dark text on bright button */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff; /* Strong neon glow */
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        button:hover {
            background: linear-gradient(45deg, #ff00ff, #00ffff); /* Reverse gradient on hover */
            box-shadow: 0 0 20px #ff00ff, 0 0 35px #00ffff;
            transform: translateY(-2px) scale(1.02);
        }

        button:active {
            transform: translateY(1px) scale(0.98);
            box-shadow: 0 0 5px #00ffff, 0 0 10px #ff00ff;
        }

        #event-area {
            width: 85%;
            max-width: 900px;
            height: 180px; /* Slightly taller */
            background-color: #0d0d1a;
            border: 2px dashed #ff66cc; /* Neon pink dashed border */
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.4em;
            color: #66ff66; /* Neon green text */
            margin-top: 25px;
            cursor: pointer;
            user-select: none;
            box-shadow: inset 0 0 15px #ff66cc55, 0 0 10px #ff66cc33; /* Inner glow */
            border-radius: 10px;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #66ff66;
        }

        #output-log {
            height: 300px; /* Taller log area */
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9em;
            color: #00e5ff; /* Log text color */
            padding: 20px;
            margin-top: 25px; /* Added padding between event-area and output-log */
        }
        .log-entry {
            margin-bottom: 8px;
            line-height: 1.5;
            text-shadow: 0 0 3px #00e5ff22;
        }
        .log-entry.triggered {
            color: #ff66cc; /* Neon pink for triggered events */
            font-weight: bold;
            text-shadow: 0 0 5px #ff66cc;
        }
        .log-entry.ignored {
            color: #7b8493; /* Subtler grey for ignored events */
            opacity: 0.7;
        }
        .log-entry.info {
            color: #66ff66; /* Neon green for info messages */
            font-weight: bold;
            text-shadow: 0 0 5px #66ff66;
        }

        .support-blurb {
            margin-top: 40px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.95em;
            color: #00e5ff;
            text-shadow: 0 0 5px #00e5ff22;
        }

        .support-blurb a {
            color: #ff00ff; /* Neon magenta links */
            text-decoration: none;
            font-weight: bold;
            text-shadow: 0 0 8px #ff00ff;
            transition: text-shadow 0.3s ease;
        }

        .support-blurb a:hover {
            text-decoration: underline;
            text-shadow: 0 0 12px #ff00ff, 0 0 20px #ff00ff;
        }

        .copyright-line {
            margin-top: 25px;
            font-size: 0.75em;
            color: #7b8493;
            text-align: center;
            width: 80%;
            font-family: 'Share Tech Mono', monospace;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <h1>Throttle Doctor: The Workbench</h1>

    <div class="controls">
        <label>
            <input type="radio" name="type" value="debounce" checked> Debounce
        </label>
        <label>
            <input type="radio" name="type" value="throttle"> Throttle
        </label>
        <label>
            Wait (ms):
            <input type="number" id="wait-time" value="300" min="50" step="50">
        </label>
        <label>
            <input type="checkbox" id="leading-edge" checked> Leading Edge
        </label>
        <label>
            <input type="checkbox" id="trailing-edge" checked> Trailing Edge
        </label>
        <div class="event-source-group">
            <label>Event Source:</label>
            <label>
                <input type="radio" name="event-source" value="mousemove"> Mouse Move
            </label>
            <label>
                <input type="radio" name="event-source" value="click"> Click
            </label>
            <label>
                <input type="radio" name="event-source" value="both" checked> Both
            </label>
        </div>
        <button onclick="applySettings()">Apply Settings and Reset</button>
    </div>

    <div id="event-area">Click or hover rapidly here!</div>

    <div id="output-log">
        <div class="log-entry">--- Event Log ---</div>
    </div>

    <div class="support-blurb">
        If you find this workbench helpful or appreciate the upcoming `Throttle Doctor` library, consider supporting its development! Your contributions help keep the project healthy and growing.
        <br><br>
        You can support me through Ko-fi: <a href="https://ko-fi.com/duroktar" target="_blank">https://ko-fi.com/duroktar</a>
        <br>
        Check out the GitHub repository: <a href="https://github.com/Duroktar/ThrottleDoctor" target="_blank">https://github.com/Duroktar/ThrottleDoctor</a>
    </div>

    <div class="copyright-line">
        &copy; Scott Doucet (@Duroktar) 2025. All rights reserved.
    </div>

    <script>
        /**
         * A higher-order function that returns a debounced or throttled version of the given function.
         *
         * @param {Function} func The function to debounce or throttle.
         * @param {number} wait The number of milliseconds to wait.
         * @param {object} [options={}] Options object.
         * @param {'debounce'|'throttle'} [options.type='debounce'] The type of control: 'debounce' or 'throttle'.
         * @param {boolean} [options.leading] If true, func is invoked on the leading edge of the timeout.
         * Defaults to true for 'throttle', false for 'debounce'.
         * @param {boolean} [options.trailing=true] If true, func is invoked on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced or throttled function.
         */
        function throttleDebounce(func, wait, options = {}) {
            const { type = 'debounce', leading = type === 'throttle', trailing = true } = options;

            if (type === 'debounce') {
                return debounce(func, wait, { leading, trailing });
            } else if (type === 'throttle') {
                return throttle(func, wait, { leading, trailing });
            } else {
                console.error("Invalid type for throttleDebounce. Must be 'throttle' or 'debounce'. Defaulting to debounce.");
                return debounce(func, wait, { leading, trailing });
            }
        }

        /**
         * Debounce HOF: Ensures the function is called only after a specified time
         * has passed since the last invocation. Each new invocation resets the timer.
         *
         * @param {Function} func The function to debounce.
         * @param {number} wait The number of milliseconds to wait.
         * @param {object} [options={}] Options object.
         * @param {boolean} [options.leading=false] If true, func is invoked on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] If true, func is invoked on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         */
        function debounce(func, wait, options = {}) {
            let timeoutId;
            let lastArgs;
            let lastThis;
            let lastResult;
            const { leading = false, trailing = true } = options;

            return function(...args) {
                lastArgs = args;
                lastThis = this;

                // Determine if this call should execute immediately (leading edge)
                // This is true if leading is enabled AND there's no active timer
                const isInvokedImmediately = leading && !timeoutId;

                // Clear any existing timer to reset the debounce countdown
                clearTimeout(timeoutId);

                // Set a new timer for the trailing call
                timeoutId = setTimeout(() => {
                    timeoutId = null; // Timer has completed

                    // If trailing is enabled AND (leading was false OR (leading was true AND it wasn't the immediate call))
                    // This ensures the trailing call happens unless leading was true and it was the *only* call
                    if (trailing && (!leading || !isInvokedImmediately)) {
                        lastResult = func.apply(lastThis, lastArgs);
                    }
                }, wait);

                // Execute immediately if leading edge is enabled and it's the first call in the sequence
                if (isInvokedImmediately) {
                    lastResult = func.apply(lastThis, lastArgs);
                }
                return lastResult;
            };
        }

        /**
         * Throttle HOF: Ensures the function is called at most once within a specified time window.
         *
         * @param {Function} func The function to throttle.
         * @param {number} wait The number of milliseconds to wait.
         * @param {object} [options={}] Options object.
         * @param {boolean} [options.leading=true] If true, func is invoked on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] If true, func is invoked on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         */
        function throttle(func, wait, options = {}) {
            let timeoutId;
            let lastArgs;
            let lastThis;
            let lastResult;
            let lastExecTime = 0; // Timestamp of the last actual function execution
            const { leading = true, trailing = true } = options;

            return function(...args) {
                const now = Date.now();
                lastArgs = args;
                lastThis = this;

                // Calculate time remaining until the next allowed execution
                const remaining = wait - (now - lastExecTime);

                // Case 1: Execute immediately (leading edge or enough time has passed)
                // `remaining > wait` handles the initial call where lastExecTime is 0
                if (remaining <= 0 || remaining > wait) {
                    if (timeoutId) { // Clear any pending trailing call from a previous burst
                        clearTimeout(timeoutId);
                        timeoutId = null;
                    }
                    lastExecTime = now; // Update the last execution time
                    lastResult = func.apply(lastThis, lastArgs);
                }
                // Case 2: Schedule a trailing call
                else if (!timeoutId && trailing) { // If no trailing call is currently scheduled AND trailing is enabled
                    timeoutId = setTimeout(() => {
                        // When the trailing call fires, update lastExecTime to now
                        // This is important for the next leading call to be correctly timed
                        lastExecTime = Date.now();
                        timeoutId = null; // Clear the timeout ID
                        lastResult = func.apply(lastThis, lastArgs);
                    }, remaining); // Schedule for the remaining time
                }
                return lastResult;
            };
        }

        // --- Demonstration Logic ---
        const eventArea = document.getElementById('event-area');
        const outputLog = document.getElementById('output-log');
        const typeRadios = document.querySelectorAll('input[name="type"]');
        const waitTimeInput = document.getElementById('wait-time');
        const leadingEdgeCheckbox = document.getElementById('leading-edge');
        const trailingEdgeCheckbox = document.getElementById('trailing-edge');
        const eventSourceRadios = document.querySelectorAll('input[name="event-source"]'); // New: Event source radios

        let eventCount = 0;
        let controlledFunction;

        function logEvent(type, message) {
            const entry = document.createElement('div');
            entry.classList.add('log-entry');
            entry.textContent = `${new Date().toLocaleTimeString()}.${String(new Date().getMilliseconds()).padStart(3, '0')} - ${message}`;
            if (type === 'triggered') {
                entry.classList.add('triggered');
            } else if (type === 'ignored') {
                entry.classList.add('ignored');
            } else if (type === 'info') { /* Added for info messages */
                entry.classList.add('info');
            }
            outputLog.prepend(entry); // Add to top
        }

        function myEventLogger() {
            logEvent('triggered', `Function executed! (Event count: ${eventCount})`);
        }

        function handleEvent() {
            eventCount++;
            logEvent('ignored', `Event fired. (Total: ${eventCount})`);
            controlledFunction(); // Call the throttled/debounced function
        }

        function attachEventListeners() {
            // Remove existing listeners first to prevent duplicates
            eventArea.removeEventListener('mousemove', handleEvent);
            eventArea.removeEventListener('click', handleEvent);

            const selectedSource = document.querySelector('input[name="event-source"]:checked').value;

            if (selectedSource === 'mousemove' || selectedSource === 'both') {
                eventArea.addEventListener('mousemove', handleEvent);
            }
            if (selectedSource === 'click' || selectedSource === 'both') {
                eventArea.addEventListener('click', handleEvent);
            }
            logEvent('info', `Event source set to: ${selectedSource}`);
        }


        function updateControlledFunction() {
            const selectedType = document.querySelector('input[name="type"]:checked').value;
            const waitTime = parseInt(waitTimeInput.value, 10);
            const leading = leadingEdgeCheckbox.checked;
            const trailing = trailingEdgeCheckbox.checked;

            // Reset event count and log
            eventCount = 0;
            outputLog.innerHTML = '<div class="log-entry">--- Event Log ---</div>';
            logEvent('info', `Configured: Type=${selectedType}, Wait=${waitTime}ms, Leading=${leading}, Trailing=${trailing}`);

            controlledFunction = throttleDebounce(myEventLogger, waitTime, {
                type: selectedType,
                leading: leading,
                trailing: trailing
            });

            attachEventListeners(); // Re-attach listeners based on new settings
        }

        function applySettings() {
            updateControlledFunction();
        }

        // Initial setup
        updateControlledFunction();

        // Attach change listeners for controls
        typeRadios.forEach(radio => radio.addEventListener('change', updateControlledFunction));
        waitTimeInput.addEventListener('change', updateControlledFunction);
        leadingEdgeCheckbox.addEventListener('change', updateControlledFunction);
        trailingEdgeCheckbox.addEventListener('change', updateControlledFunction);
        eventSourceRadios.forEach(radio => radio.addEventListener('change', updateControlledFunction)); // New: Event source change listener
    </script>
</body>
</html>
