<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throttle Doctor</title>
    <!-- Google Analytics (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QDX3CMJMMQ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-QDX3CMJMMQ');
    </script>
    <!-- End Google Analytics -->
    <style>
        /* Import fonts for both themes */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Arial&display=swap'); /* Fallback/Original theme font */

        /* --- Base / Original Theme Styles (Default) --- */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: #282c34; /* Dark background */
            color: #abb2bf; /* Light text */
            overflow-x: hidden;
            position: relative;
            gap: 25px; /* Unified vertical spacing between direct children */
            padding-bottom: 1em; /* Added space at the bottom */
        }

        body::before { /* Remove grid for original theme */
            content: none;
        }

        h1 {
            font-family: Arial, sans-serif;
            font-weight: 700;
            font-size: 2.5em;
            color: #61afef; /* Light blue heading */
            text-shadow: none;
            margin-bottom: 0; /* Managed by body gap */
            padding-top: 20px;
        }

        .controls, .support-blurb, #event-area, #log-section {
            background-color: #323842; /* Darker panel background */
            border: 1px solid #4a515c; /* Grey border */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 0; /* Managed by body gap */
            width: 85%;
            max-width: 900px;
            box-sizing: border-box;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .controls::before, .support-blurb::before, #event-area::before, #log-section::before {
            content: none; /* Remove inner glow for original theme */
        }

        .controls label {
            font-family: Arial, sans-serif;
            font-size: 1em;
            color: #abb2bf;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .controls input[type="radio"],
        .controls input[type="checkbox"] {
            accent-color: #61afef;
            transform: scale(1);
        }

        .controls input[type="number"] {
            width: 80px;
            padding: 8px 12px;
            border: 1px solid #4a515c;
            background-color: #21252b;
            color: #abb2bf;
            border-radius: 6px;
            font-family: Consolas, monospace;
            font-size: 1em;
            box-shadow: none;
        }

        button {
            font-family: Arial, sans-serif;
            padding: 14px 30px;
            font-size: 1.1em;
            background: #61afef; /* Solid blue button */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            font-weight: bold;
            letter-spacing: normal;
            text-transform: none;
        }

        button:hover {
            background: #528bff;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px) scale(1.02);
        }

        button:active {
            transform: translateY(1px) scale(0.98);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #event-area {
            height: 180px;
            background-color: #0d1117;
            border: 2px dashed #4a515c;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Consolas, monospace;
            font-size: 1.4em;
            color: #98c379;
            margin-top: 0; /* Managed by body gap */
            cursor: pointer;
            user-select: none;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            letter-spacing: normal;
            text-shadow: none;
        }

        #log-section {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Space between output-log and log options */
            padding: 20px; /* Adjust padding as it now contains children */
            background-color: #323842; /* Match controls background */
            border: 1px solid #4a515c; /* Match controls border */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* Match controls shadow */
            border-radius: 8px; /* Match controls border-radius */
        }

        #output-log {
            height: 300px;
            width: inherit; /* Set width to 100% of its parent (#log-section) */
            font-family: Consolas, monospace;
            font-size: 0.9em;
            color: #c9d1d9;
            padding: 15px; /* Inner padding for the log entries */
            margin-top: 0; /* Managed by #log-section gap */
            overflow: auto; /* Changed to auto for better scroll behavior */
            background-color: #0d1117; /* Darker background for log area */
            border: 1px solid #4a515c; /* Border for log area */
            border-radius: 6px; /* Rounded corners for log area */
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); /* Inner shadow for log area */
        }
        .log-entry {
            margin-bottom: 8px;
            line-height: 1.5;
            text-shadow: none;
        }
        .log-entry.triggered {
            color: #61afef;
            font-weight: bold;
            text-shadow: none;
        }
        .log-entry.ignored {
            color: #7b8493;
            opacity: 1;
        }
        .log-entry.info {
            color: #98c379;
            font-weight: bold;
            text-shadow: none;
        }

        .support-blurb {
            margin-top: 0; /* Managed by body gap */
            font-family: Arial, sans-serif;
            font-size: 0.95em;
            color: #abb2bf;
            text-shadow: none;
            text-align: left; /* Align text to the left */
            display: flex; /* Make it a flex container */
            flex-direction: column; /* Stack children vertically */
            gap: 10px; /* Space between lines */
        }

        .support-blurb a {
            color: #61afef;
            text-decoration: none;
            font-weight: bold;
            text-shadow: none;
            transition: text-shadow 0.3s ease;
        }

        .support-blurb a:hover {
            text-decoration: underline;
            text-shadow: none;
        }

        .copyright-line {
            margin-top: 0; /* Managed by body gap */
            font-size: 0.75em;
            color: #7b8493;
            width: 80%;
            font-family: Arial, sans-serif;
            opacity: 1;
            display: flex; /* Use flexbox */
            justify-content: space-between; /* Space items out */
            align-items: center; /* Vertically align items */
            padding: 0 10px; /* Add some padding on the sides */
        }

        .copyright-line .version-text {
            font-size: 0.9em; /* Slightly larger for visibility */
            color: #abb2bf; /* Match main text color */
            font-weight: bold;
        }

        /* Theme Toggle Switch Styles */
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 0; /* Managed by body gap */
            font-family: 'Share Tech Mono', monospace;
            color: #00e5ff;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #ff00ff; /* Neon magenta when checked */
            box-shadow: 0 0 8px #ff00ff;
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #ff00ff;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
            background-color: #00ffff; /* Neon cyan dot when checked */
        }

        /* --- Neon Theme Overrides (Applied when body has .neon-theme class) --- */
        body.neon-theme {
            font-family: 'Orbitron', sans-serif;
            background-color: #0a0a1a;
            color: #00ffff;
        }
        body.neon-theme::before {
            content: '';
            background-image:
                linear-gradient(to right, #00ffff11 1px, transparent 1px),
                linear-gradient(to bottom, #00ffff11 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.1;
        }

        body.neon-theme h1 {
            font-family: 'Orbitron', sans-serif;
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff, 0 0 15px #ff00ff;
            letter-spacing: 2px;
        }

        body.neon-theme .controls,
        body.neon-theme .support-blurb,
        body.neon-theme #event-area,
        body.neon-theme #log-section {
            background-color: #1a1a2e;
            border: 1px solid #00ffff;
            box-shadow: 0 0 10px #00ffff44, inset 0 0 5px #00ffff22;
        }

        body.neon-theme .controls::before,
        body.neon-theme .support-blurb::before,
        body.neon-theme #event-area::before,
        body.neon-theme #log-section::before {
            content: '';
            box-shadow: 0 0 20px #ff00ff44, inset 0 0 10px #ff00ff22;
            opacity: 0.1;
        }

        body.neon-theme .controls label {
            font-family: 'Share Tech Mono', monospace;
            color: #00e5ff;
        }

        body.neon-theme .controls input[type="radio"],
        body.neon-theme .controls input[type="checkbox"] {
            accent-color: #ff00ff;
            transform: scale(1.2);
        }

        body.neon-theme .controls input[type="number"] {
            background-color: #0d0d1a;
            color: #66ff66;
            border: 1px solid #00ffff;
            box-shadow: inset 0 0 5px #00ffff33;
        }

        body.neon-theme button {
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            color: #0a0a1a;
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        body.neon-theme button:hover {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            box-shadow: 0 0 20px #ff00ff, 0 0 35px #00ffff;
        }

        body.neon-theme #event-area {
            background-color: #0d0d1a;
            border: 2px dashed #ff66cc;
            font-family: 'Share Tech Mono', monospace;
            color: #66ff66;
            box-shadow: inset 0 0 15px #ff66cc55, 0 0 10px #ff66cc33;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #66ff66;
        }

        body.neon-theme #output-log {
            font-family: 'Share Tech Mono', monospace;
            color: #00e5ff;
            background-color: #0d0d1a; /* Darker background for log area */
            border: 1px solid #00ffff66; /* Neon border for log area */
            box-shadow: inset 0 0 5px #00ffff22; /* Inner shadow for log area */
        }
        body.neon-theme .log-entry {
            text-shadow: 0 0 3px #00e5ff22;
        }
        body.neon-theme .log-entry.triggered {
            color: #ff66cc;
            text-shadow: 0 0 5px #ff66cc;
        }
        body.neon-theme .log-entry.ignored {
            color: #7b8493;
            opacity: 0.7;
        }
        body.neon-theme .log-entry.info {
            color: #66ff66;
            text-shadow: 0 0 5px #66ff66;
        }

        body.neon-theme .support-blurb {
            font-family: 'Share Tech Mono', monospace;
            color: #00e5ff;
            text-shadow: 0 0 5px #00e5ff22;
        }

        body.neon-theme .support-blurb a {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
        }

        body.neon-theme .support-blurb a:hover {
            text-shadow: 0 0 12px #ff00ff, 0 0 20px #ff00ff;
        }

        body.neon-theme .copyright-line {
            font-family: 'Share Tech Mono', monospace;
            opacity: 0.6;
        }
        body.neon-theme .copyright-line .version-text {
            color: #00ffff; /* Neon cyan for version text */
        }

        /* New Grouping Styles */
        .option-group {
            border: 1px solid #4a515c; /* Default border */
            border-radius: 6px;
            padding: 10px 15px;
            padding-bottom: 15px; /* Increased bottom padding */
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            background-color: #21252b; /* Slightly lighter background for groups */
            margin: 5px 0; /* Small margin around groups */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); /* Subtle inner shadow */
        }
        .option-group-title {
            font-weight: bold;
            color: #c9d1d9; /* Default title color */
            width: 100%; /* Ensure title takes full width */
            margin-bottom: 5px;
            font-size: 0.9em;
            border-bottom: 1px solid #4a515c; /* Separator under title */
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        /* Specific layout for Function Type group */
        .function-type-group {
            flex-direction: column;
            align-items: flex-start; /* Align items to the start in column layout */
            gap: 5px; /* Smaller gap for stacked items */
        }

        /* Neon Theme Grouping Overrides */
        body.neon-theme .option-group {
            border: 1px solid #00ffff66; /* Neon border */
            background-color: #0d0d1a; /* Darker neon group background */
            box-shadow: inset 0 0 5px #00ffff11, 0 0 5px #00ffff11;
        }
        body.neon-theme .option-group-title {
            color: #66ff66; /* Neon green title color */
            text-shadow: 0 0 5px #66ff66;
            border-bottom: 1px solid #00ffff66; /* Neon separator */
        }
    </style>
</head>
<body class="original-theme"> <!-- Default to original theme -->
    <h1>Throttle Doctor 💉</h1>

    <div class="theme-toggle">
        <span>Original Theme</span>
        <label class="switch">
            <input type="checkbox" id="theme-toggle-switch"> <!-- Default to unchecked (original) -->
            <span class="slider"></span>
        </label>
        <span>Neon Cyberpunk</span>
    </div>

    <div class="controls">
        <div class="option-group function-type-group"> <!-- Added function-type-group class -->
            <span class="option-group-title">Function Type:</span>
            <label>
                <input type="radio" name="type" value="debounce" checked> Debounce
            </label>
            <label>
                <input type="radio" name="type" value="throttle"> Throttle
            </label>
        </div>

        <div class="option-group">
            <span class="option-group-title">Timing & Edges:</span>
            <label>
                Wait (ms):
                <input type="number" id="wait-time" value="300" min="50" step="50">
            </label>
            <label>
                <input type="checkbox" id="leading-edge" checked> Leading Edge
            </label>
            <label>
                <input type="checkbox" id="trailing-edge" checked> Trailing Edge
            </label>
        </div>

        <div class="option-group">
            <span class="option-group-title">Event Source:</span>
            <label>
                <input type="radio" name="event-source" value="mousemove"> Mouse Move
            </label>
            <label>
                <input type="radio" name="event-source" value="click"> Click
            </label>
            <label>
                <input type="radio" name="event-source" value="both" checked> Both
            </label>
        </div>
        
        <button onclick="applySettings()">Reset Event Log</button>
    </div>

    <div id="event-area">Click or hover rapidly here!</div>

    <div id="log-section">
        <div id="output-log">
            <div class="log-entry">--- Event Log ---</div>
        </div>
    </div>

    <div class="support-blurb">
        <div>If you find this workbench helpful or appreciate the upcoming `Throttle Doctor` library, consider supporting its development! Your contributions help keep the project healthy and growing.</div>
        <div>You can support me through Ko-fi: <a href="https://ko-fi.com/duroktar" target="_blank">https://ko-fi.com/duroktar</a></div>
        <div>Check out the GitHub repository: <a href="https://github.com/Duroktar/ThrottleDoctor" target="_blank">https://github.com/Duroktar/ThrottleDoctor</a></div>
    </div>

    <div class="copyright-line">
        <span>&copy; Scott Doucet (@Duroktar) 2025. All rights reserved.</span>
        <span class="version-text">v1.0.1</span>
    </div>

    <script>
        /**
         * A higher-order function that returns a debounced or throttled version of the given function.
         *
         * @param {Function} func The function to debounce or throttle.
         * @param {number} wait The number of milliseconds to wait.
         * @param {object} [options={}] Options object.
         * @param {'debounce'|'throttle'} [options.type='debounce'] The type of control: 'debounce' or 'throttle'.
         * @param {boolean} [options.leading] If true, func is invoked on the leading edge of the timeout.
         * Defaults to true for 'throttle', false for 'debounce'.
         * @param {boolean} [options.trailing=true] If true, func is invoked on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced or throttled function.
         */
        function throttleDebounce(func, wait, options = {}) {
            const { type = 'debounce', leading = type === 'throttle', trailing = true } = options;

            if (type === 'debounce') {
                return debounce(func, wait, { leading, trailing });
            } else if (type === 'throttle') {
                return throttle(func, wait, { leading, trailing });
            } else {
                console.error("Invalid type for throttleDebounce. Must be 'throttle' or 'debounce'. Defaulting to debounce.");
                return debounce(func, wait, { leading, trailing });
            }
        }

        /**
         * Debounce HOF: Ensures the function is called only after a specified time
         * has passed since the last invocation. Each new invocation resets the timer.
         *
         * @param {Function} func The function to debounce.
         * @param {number} wait The number of milliseconds to wait.
         * @param {object} [options={}] Options object.
         * @param {boolean} [options.leading=false] If true, func is invoked on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] If true, func is invoked on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         */
        function debounce(func, wait, options = {}) {
            let timeoutId;
            let lastArgs;
            let lastThis;
            let lastResult;
            const { leading = false, trailing = true } = options;

            return function(...args) {
                lastArgs = args;
                lastThis = this;

                // Determine if this call should execute immediately (leading edge)
                // This is true if leading is enabled AND there's no active timer
                const isInvokedImmediately = leading && !timeoutId;

                // Clear any existing timer to reset the debounce countdown
                clearTimeout(timeoutId);

                // Set a new timer for the trailing call
                timeoutId = setTimeout(() => {
                    timeoutId = null; // Timer has completed

                    // If trailing is enabled AND (leading was false OR (leading was true AND it wasn't the immediate call))
                    // This ensures the trailing call happens unless leading was true and it was the *only* call
                    if (trailing && (!leading || !isInvokedImmediately)) {
                        lastResult = func.apply(lastThis, lastArgs);
                    }
                }, wait);

                // Execute immediately if leading edge is enabled and it's the first call in the sequence
                if (isInvokedImmediately) {
                    lastResult = func.apply(lastThis, lastArgs);
                }
                return lastResult;
            };
        }

        /**
         * Throttle HOF: Ensures the function is called at most once within a specified time window.
         *
         * @param {Function} func The function to throttle.
         * @param {number} wait The number of milliseconds to wait.
         * @param {object} [options={}] Options object.
         * @param {boolean} [options.leading=true] If true, func is invoked on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] If true, func is invoked on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         */
        function throttle(func, wait, options = {}) {
            let timeoutId;
            let lastArgs;
            let lastThis;
            let lastResult;
            let lastExecTime = 0; // Timestamp of the last actual function execution
            const { leading = true, trailing = true } = options;

            return function(...args) {
                const now = Date.now();
                lastArgs = args;
                lastThis = this;

                // Calculate time remaining until the next allowed execution
                const remaining = wait - (now - lastExecTime);

                // Case 1: Execute immediately (leading edge or enough time has passed)
                // `remaining > wait` handles the initial call where lastExecTime is 0
                if (remaining <= 0 || remaining > wait) {
                    if (timeoutId) { // Clear any pending trailing call from a previous burst
                        clearTimeout(timeoutId);
                        timeoutId = null;
                    }
                    lastExecTime = now; // Update the last execution time
                    lastResult = func.apply(lastThis, lastArgs);
                }
                // Case 2: Schedule a trailing call
                else if (!timeoutId && trailing) { // If no trailing call is currently scheduled AND trailing is enabled
                    timeoutId = setTimeout(() => {
                        // When the trailing call fires, update lastExecTime to now
                        // This is important for the next leading call to be correctly timed
                        lastExecTime = Date.now();
                        timeoutId = null; // Clear the timeout ID
                        lastResult = func.apply(lastThis, lastArgs);
                    }, remaining); // Schedule for the remaining time
                }
                return lastResult;
            };
        }

        // --- Demonstration Logic ---
        const eventArea = document.getElementById('event-area');
        const outputLog = document.getElementById('output-log');
        const typeRadios = document.querySelectorAll('input[name="type"]');
        const waitTimeInput = document.getElementById('wait-time');
        const leadingEdgeCheckbox = document.getElementById('leading-edge');
        const trailingEdgeCheckbox = document.getElementById('trailing-edge');
        const eventSourceRadios = document.querySelectorAll('input[name="event-source"]');
        const themeToggleSwitch = document.getElementById('theme-toggle-switch');

        let eventCount = 0;
        let controlledFunction;
        let logEntries = []; // Array to store all log entries

        /**
         * Logs an event to the output log.
         * @param {string} type - The type of log entry ('triggered', 'ignored', 'info').
         * @param {string} message - The message to display.
         */
        function logEvent(type, message) {
            const timestamp = `${new Date().toLocaleTimeString()}.${String(new Date().getMilliseconds()).padStart(3, '0')}`;
            const entry = { timestamp: new Date(), type: type, message: `${timestamp} - ${message}` }; // Store full timestamp for sorting
            logEntries.push(entry);
            renderLog();
        }

        /**
         * Renders the log entries to the output log, sorting by newest first.
         */
        function renderLog() {
            // Clear and add the header
            outputLog.innerHTML = '<div class="log-entry">--- Event Log ---</div>';
            
            // Sort logEntries by newest first (descending timestamp)
            let entriesToRender = [...logEntries].sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

            for (const entryData of entriesToRender) {
                const entryElement = document.createElement('div');
                entryElement.classList.add('log-entry');
                entryElement.textContent = entryData.message;
                if (entryData.type === 'triggered') {
                    entryElement.classList.add('triggered');
                } else if (entryData.type === 'ignored') {
                    entryElement.classList.add('ignored');
                } else if (entryData.type === 'info') {
                    entryElement.classList.add('info');
                }
                // Append new entries to the log
                outputLog.appendChild(entryElement);
            }
            // Always scroll to the top to show the newest entries
            outputLog.scrollTop = 0;
        }

        /**
         * The function that gets debounced/throttled and logs its execution.
         */
        function myEventLogger() {
            logEvent('triggered', `Function executed! (Event count: ${eventCount})`);
        }

        /**
         * Handles the raw event from the event area.
         */
        function handleEvent() {
            eventCount++;
            logEvent('ignored', `Event fired. (Total: ${eventCount})`);
            controlledFunction();
        }

        /**
         * Attaches event listeners based on selected event source.
         */
        function attachEventListeners() {
            eventArea.removeEventListener('mousemove', handleEvent);
            eventArea.removeEventListener('click', handleEvent);

            const selectedSource = document.querySelector('input[name="event-source"]:checked').value;

            if (selectedSource === 'mousemove' || selectedSource === 'both') {
                eventArea.addEventListener('mousemove', handleEvent);
            }
            if (selectedSource === 'click' || selectedSource === 'both') {
                eventArea.addEventListener('click', handleEvent);
            }
            logEvent('info', `Event source set to: ${selectedSource}`);
            updateEventAreaText(selectedSource); // Update text when listeners are attached
        }

        /**
         * Updates the text content of the event area based on the selected event source.
         * @param {string} selectedSource - The value of the selected event source radio button.
         */
        function updateEventAreaText(selectedSource) {
            switch (selectedSource) {
                case 'mousemove':
                    eventArea.textContent = "Hover here!";
                    break;
                case 'click':
                    eventArea.textContent = "Click rapidly here!";
                    break;
                case 'both':
                    eventArea.textContent = "Click or hover here!";
                    break;
                default:
                    eventArea.textContent = "Interact here!";
            }
        }


        /**
         * Updates the controlled (debounced/throttled) function based on current settings.
         * Resets event count and log.
         */
        function updateControlledFunction() {
            const selectedType = document.querySelector('input[name="type"]:checked').value;
            const waitTime = parseInt(waitTimeInput.value, 10);
            const leading = leadingEdgeCheckbox.checked;
            const trailing = trailingEdgeCheckbox.checked;

            eventCount = 0;
            logEntries = []; // Clear log entries
            logEvent('info', `Configured: Type=${selectedType}, Wait=${waitTime}ms, Leading=${leading}, Trailing=${trailing}`);

            controlledFunction = throttleDebounce(myEventLogger, waitTime, {
                type: selectedType,
                leading: leading,
                trailing: trailing
            });

            attachEventListeners();
            renderLog();
        }

        /**
         * Function called by the "Apply Settings and Reset" button.
         */
        function applySettings() {
            updateControlledFunction();
        }

        // --- Theme Switching Logic ---
        /**
         * Applies the selected theme to the body and saves preference to local storage.
         * @param {boolean} isNeon - True to apply neon theme, false for original.
         */
        function applyTheme(isNeon) {
            if (isNeon) {
                document.body.classList.add('neon-theme');
                localStorage.setItem('theme', 'neon');
            } else {
                document.body.classList.remove('neon-theme');
                localStorage.setItem('theme', 'original');
            }
        }

        // Load theme preference from localStorage on page load
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'neon') {
            themeToggleSwitch.checked = true;
            applyTheme(true);
        } else {
            themeToggleSwitch.checked = false;
            applyTheme(false);
        }

        // Event listener for theme toggle switch
        themeToggleSwitch.addEventListener('change', (event) => {
            applyTheme(event.target.checked);
        });

        // Initial setup
        updateControlledFunction();

        // Attach change listeners for controls
        typeRadios.forEach(radio => radio.addEventListener('change', updateControlledFunction));
        waitTimeInput.addEventListener('change', updateControlledFunction);
        leadingEdgeCheckbox.addEventListener('change', updateControlledFunction);
        trailingEdgeCheckbox.addEventListener('change', updateControlledFunction);
        eventSourceRadios.forEach(radio => radio.addEventListener('change', updateControlledFunction));
    </script>
</body>
</html>
